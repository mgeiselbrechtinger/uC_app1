%***************************************************************************
% MCLab Protocol Template
%
% Embedded Computing Systems Group
% Institute of Computer Engineering
% TU Vienna
%
%---------------------------------------------------------------------------
% Vers. Author Date     Changes
% 1.0   bw     10.03.06 first version
% 1.1   bw     25.04.06 listing is in a different directory
% 1.2   bw     24.05.06 tutor has to be listed on title page
% 1.3   bw     16.06.06 statement about no plagiarism on title page (sign it!)
% 1.4   mp     21.07.15 changed coversheet, rewording
%---------------------------------------------------------------------------
% Author names:
%       bw      Bettina Weiss
%       mp      Martin Perner
%***************************************************************************

\documentclass[12pt,a4paper,titlepage,oneside]{article}
\usepackage{graphicx}            % fuer Bilder
\usepackage{listings}            % fuer Programmlistings
%\usepackage{german}              % fuer deutsche Umbrueche
\usepackage[latin1]{inputenc}    % fuer Umlaute
\usepackage{times}               % PDF files look good on screen
\usepackage{amssymb,amsmath,amsthm}
\usepackage{url}
\usepackage{enumitem}
\usepackage{fullpage}
\usepackage{tikz}
\usepackage[capitalize,nameinlink,noabbrev]{cleveref}

\lstset{language=C,
	frame=single,
	captionpos=b,
}


%***************************************************************************
% note: the template is in English, but you can use German for your
% protocol as well; in that case, remove the comment from the
% \usepackage{german} line above
%***************************************************************************


%***************************************************************************
% enter your data into the following fields
%***************************************************************************
\newcommand{\Vorname}{Max}
\newcommand{\Nachname}{Geiselbrechtinger}
\newcommand{\MatrNr}{01609418}
\newcommand{\Email}{e1609418@student.tuwien.ac.at}
\newcommand{\Part}{I}
%***************************************************************************


%***************************************************************************
% generating the document from Protocol.tex:
%       "pdflatex Protocol"        generates a .pdf file
%       "pdflatex Protocol"        repeat to get correct table of contents
%       "evince Protocol.pdf &"    shows the .pdf file on viewer
%
%***************************************************************************

%---------------------------------------------------------------------------
% include all the stuff that is the same for all protocols and students
\input ProtocolHeader.tex
%---------------------------------------------------------------------------

\begin{document}

%---------------------------------------------------------------------------
% create titlepage and table of contents
\MakeTitleAndTOC
%---------------------------------------------------------------------------


%***************************************************************************
% This is where your protocol starts
%***************************************************************************


%***************************************************************************
\section{Overview}
%***************************************************************************

%---------------------------------------------------------------------------
\subsection{Connections,  External Pullups/Pulldowns}
%---------------------------------------------------------------------------

\bConnections{bigAVR6}{smartMP3}
    \hline \hline
    & J1 connected to 5V \\
    & J5 connected to SP OUT1+ \\
    & J6 connected to SP OUT1- \\ \hline
    PB0 & Connected to MP3\_CS \\
    PB1 & Connected to SCK \\
    PB2 & Connected to MOSI \\
    PB3 & Connected to MISO \\
    PB4 & Connected to MP3\_RST \\
    PB5 & Connected to BSYNC \\
    PD0 & Connected to DREQ \\
    PG1 & Connected to MMC\_CS \\ \hline
    VCC & Connected to VCC \\
    GND & Connected to GND \\ \hline \hline
    bigAVR6 & WT41\_Bluetooth \\ \hline \hline
    & JP RTS/CTS on \\ \hline
    PJ0 & Connected to TX \\
    PJ1 & Connected to RX \\
    PJ2 & Connected to RTS \\
    PJ3 & Connected to CTS \\
    PJ5 & Connected to RST \\ \hline
    VCC & Connected to VCC \\
    GND & Connected to GND \\ \hline \hline
    bigAVR6 & ADC \\ \hline \hline
    J15 connected to PF0 & \\
    P5 adjust volume & \\ \hline \hline
    bigAVR6 & GLCD \\ \hline \hline
    SW14 LCD-BGLIGHT to VCC & \\
    P3 adjust brightness & \\
\eConnections

\noindent
All other DIP-Switches, that were not mentioned in this section, have to be switched off.
Also every Jumper, that has not been mentionded, can be set arbitrarily. 

\noindent
If multiple resets of the bigAVR6 board occur, it is recommended to use an
external power supply.

\noindent
The smartMP3 extension board has to be equiped with a valid SD-card, otherwise initialization
will fail.

%---------------------------------------------------------------------------
\subsection{Design Decisions}
%---------------------------------------------------------------------------

\begin{itemize}

    \item \textbf{SD-Card:} A sdcard has to be present during the whole runtime
        of the application. Removing the sdcard after the initialization should
        not affect the gameplay, in any way other than stopping music playback.
        But it is not recommended to do this. \\

    \item \textbf{GLCD:} The glcd's hal filters all input addresses, through
        a modulo operation. This results in the effect, that drawing or 
        writing text above any of the screens border will continue on the
        opposite edge of the screen. \\ 
        The text writing function will handle newlines according to the GNU
        style. Any other format of newlines will result in an undefined behaviour.
        Also the program memory text writing function is limited to a string
        length of 32 characters, including the null terminator. \\

    \item \textbf{Wiimote:} The wii\_user.c file of the libwiimote library has 
        been modified to include dissabling of the wii's accelerometers. \\
        % TODO write about reconnect

    \item \textbf{Music:} The music playback is implemented as background task, which shovels junks of 32 bytes
        from the SD-card to the mp3-decoder as long as the mp3-decoder is not busy. It then remains
        IDLE, until the mp3-decoder requests more data. Volume will be adjusted if a new 
        volume value has been generated by the ADC and no data transmission to the mp3-decoder
        is currently active. \\

    \item \textbf{ADC:} The adc issues a conversion every 5ms, and afterwards it switches the convesion mode. The volume
        is sampled through single conversion mode, where as the noise, used to seed the rand module, is generated 
        through differential conversion mode of two floating input pins. \\
    
    \item \textbf{Rand:} The rand's linear feedback shift register is implemented through inline
        assembler to ensure true and efficient operation. The module also includes a rand8 function, which 
        outputs random 8bit values.\\

    \item \textbf{Menu:} The menu is concipated as background task, but execution is restricted to 20Hz, to
        provide consistent game updates. It consists of a top-level state machine which handles connection to
        the Wiimote, the menu itself and the gameplay. All of the states contain state machines themselves, to remove 
        redundancy and ensure progress of other background tasks. \\

    \item \textbf{Gameplay:} The gameplay is located in the gameloop menu state. To move platforms from bottom to
        top the RAM-shift of the glcd controllers is used. It starts by shifting every 6 game ticks until a threshold of 30
        points is reached, then it will decrement the game tick threshold for the next shift by one and multiply the threshold
        by two. This happens until shifting occurs at each game tick. Every 14 shifts, a new platform, which is randomly chosen
        out of a set of platforms, gets inserted on the bottom of the screen. The ball can only move one pixel per game 
        tick in x-direction but will fall two pixels per game
        tick downwards if no platform is beneath it. To manage the collision detection a ringbuffer holds all platforms
        under the ball. The platform right beneath the ball is checked for gaps to let the ball pass, otherwise the ball
        will be shifted up with the platform. The score is incremented every second and consists of a 16bit unsinged integer,
        to ensure that no overflow will occur during a long period of gameplay. \\

\end{itemize}

%---------------------------------------------------------------------------
\subsection{Specialities}
%---------------------------------------------------------------------------

\begin{itemize}

    \item \textbf{Positiv:} I am quite satisfied with the way I implemented the menu. Particularly the player select
        came out really nice. Also the collision detection is managed in an efficient way I think. 

    \item \textbf{Negativ:} There is definetly space to advance the game expirience, such as faster shifts, different 
        ball speeds or more random platforms. Also I would prefer if the gameplay would be outsourced in an external 
        module, to keep the menu's code clearer. \\

\end{itemize}

\newpage

%***************************************************************************
\section{Main Application}
%***************************************************************************

To control the application, a Wiimote has to be connected. To do so, you
have to set the MAC-address in the file \emph{mac.h}, inside the top-level
directory, corresponding to the Wiimote's MAC-address. Note, issue a \emph{make
clean install} to make sure that the new MAC-address gets applied.

\noindent
Then you will be asked to connect the Wiimote to the board. Do so, by pressing
any button and wait until the Leds of the controller stop flashing. If Led 1 
lights up, the connection has succesfully been established and you will see the
homescreen of the game on the GLCD. If not, try pressing the sync button behind the
battery cover. 

\noindent
In the game menu you can switch to the highscore board or the user select by
issuing button 1 or 2 respectively. To get back to the home screen simply press
button B. 

\noindent
The highscore board shows the five highest achieved scores since the last reset. 
Scores are sorted in ascending order, from top to bottom.

\noindent
In the player select menu you can choose a player number though using the up and 
down arrow buttons. After selecting your player with button A the game will start 
right away.

\noindent
During the game random platforms will stream
from bottom to top. The ball should be moved left or right, by tilting the 
Wiimote left or right respectively, to fall through the gaps. The game ends if
the ball hits the top of the screen or the home button is pressed. After every
game the highscore table is shown. From there on you can move through the menu
again as explained before.

%***************************************************************************
\subsection{Main}
%***************************************************************************

The main function is in charge of calling all initialization functions
required for the application. It also calls the music playback and the game play
functions. After returning from these functions it puts the CPU into a power
saving IDLE mode.
\noindent
The main function depends on all modules of the following sections.

%***************************************************************************
\section{Music Playback}
%***************************************************************************

While the application is runnig a fancy song, stored on the sd-card, is played over 
the speakers of the mp3 extension board. The volume of the music can be adjusted 
through the potentiometer P5 on the bigAVR6 board.
\noindent
This module relies on the libmp3 and libsdcard library, provided by the LVA-team.

%---------------------------------------------------------------------------
\subsection{SPI}
%---------------------------------------------------------------------------

The SPI module provides an extra layer of abstraction to the mp3 and sd-card
user application. After the SPI has been initialized the module can be used
to send or receive data bytes over the spi bus. This module is required to 
ensure operation of the libmp3 and libsdcard libraries. 

%***************************************************************************
\section{ADC}
%***************************************************************************

The ADC module is serving two tasks. One is to provide a seed for the PRNG 
and the other is to read the volume setting of potentiometer P5.

%---------------------------------------------------------------------------
\subsection{RAND}
%---------------------------------------------------------------------------

The rand module consist of a pseudo random number generator which is seeded
though noise of the ADC to increase randomness. The random numbers are used
to index an array of platforms to generate a pseudorandom level.
\noindent
The random number generator relies on the ADC module.

%***************************************************************************
\section{LC--Display}
%***************************************************************************

The menu and game play is visualized on the 128 by 64 pixel GLCD. 

%---------------------------------------------------------------------------
\subsection{GLCD}
%---------------------------------------------------------------------------

The glcd user module provides an extra layer of abstraction to the user 
application. It depends on the glcd hal module and consists of basic pixel
manipulation functions, as well as more advanced drawing and text writing 
functions (eg. draw circle, fill rectangle or write text). 

%---------------------------------------------------------------------------
\subsection{HAL GLCD}
%---------------------------------------------------------------------------

The hardware abstraction layer of the glcd handles the communication with 
the two glcd controller. It allows acces to byte-sized pages of the y-axis, for
every x-coordinate. The module has to memorize the latest address to handle the
post increment of x-coordinate after read or write commands and to handle 
requests to the y-shift's state. It also manages a fluent switch between the 
controllers after a post increment. Through changing the controllers RAM start
address a efficient screen shift, in the y direction, can be implemented. 

%***************************************************************************
\section{WII MOTE}
%***************************************************************************

The libwiimote library presents a high level interface to the user application
to communicate with the Wiimote.
\noindent
The library is provided by the LVA-team but requires the wt41 hal module to
be present.

%***************************************************************************
\subsection{HAL WT41}
%***************************************************************************

The hardware abstraction layer of the wt41 module handles the UART
connection to the bluetooth extension board. To ensure propper functionality
the module includes a 32 byte ringbuffer to store received data.

%***************************************************************************
\section{MENU}
%***************************************************************************

The menu module handles the game menu and game play. It receives input from
the Wiimote and issues output to the GLCD. 
\noindent
It depends on the GLCD and Wiimote module. 

\newpage

%***************************************************************************
\section{Problems}
%***************************************************************************

After a revision of the specification I did not notice that the version of the
libsdcard was updated and therefore wasn't able to get my music playback running.
\noindent
I also encountered problems while compiling the glcd module with advanced 
optimization modes. This led to drastically slowing down my module. 

%***************************************************************************
\section{Work}
%***************************************************************************

The assumption column was left free, because I hadn't really worked on microcontrollers 
yet, nor had I programmed a project of this size before. Therefore I had no estimations
on how long something should take me. I also did not protocol my working time precisely, therefore
the times in the table are estimated values. Nevertheless I have spent quite a lot of time 
debugging correct code because of other bugs, like depreciated libraries or wrong 
compiler flags. 

\begin{tabular}{|l|c|c|}\hline
	Task & Assumption (IP) & Reality \\ \hline

	reading manuals, datasheets &  & 15 h\\
	program design              &  & 20 h\\
	programming                 &  & 10 h\\
	debugging                   &  & 80 h\\
	protocol                    &  &  5 h\\ \hline

	\textbf{Total}              &  &130 h\\ \hline
\end{tabular}


%***************************************************************************
\newpage
\end{document}

